#!/bin/zsh

# wordle_solver.part3.v0.2
# Wordle solver subscript by gsb

  if [[ "$VERBOSITY" -ge 1 ]]; then
    print "wordle_solver.part3.v0.2"
    print
  fi

  # Determine unmatched letters in guess
  WRONG=$( echo "${GUESS[$i]}" | tr -d "$LET" | tr -d "$CORRECT" )

  if [[ "$WRONG" = "" ]]; then
    print "No unmatched letters. Wordle is solved - or very close."
    return
  else
    print "That means the unmatched letter(s) were \"$WRONG\"."
    print
  fi
  
  PART3=$(wc -l < list.tmp)
  PART3=${PART3// }

  # Iterate through letters in $WRONG

  LEN="${#WRONG}"
  if [[ "$VERBOSITY" -eq 2 ]]; then
    print "Number of letters not matched is $LEN"
    print
  fi

  if [[ "$LEN" -gt 5 ]]; then
    print
    print "Error - more than 5 letters in $WRONG."
    exit

  elif [[ "$LEN" -ge 1 ]]; then

    # Loop through unmatched letters
    for j in {1..$LEN}; do
      OFFSET=$(( $j-1 ))
      if [[ "$VERBOSITY" -eq 2 ]]; then
        print "\$OFFSET is $OFFSET"
      fi
      LETTER=${WRONG:$OFFSET:1}
      if [[ "$VERBOSITY" -eq 2 ]]; then
        print "\$LETTER is $LETTER"
      fi

      # Check if letter is duplicated in guess
      COUNT=$( grep -o $LETTER <<<${GUESS[i]} | wc -l ) 
      COUNT=${COUNT// }
      if [[ $? -ne 0 ]]; then
        print "Error in grep - \$\?=$?"
      fi
            
      if [[ "$COUNT" -eq 0 ]]; then
        print "ERROR - $LETTER does not actually exist in ${GUESS[i]}"
        exit
          
      elif [[ "$COUNT" -gt 3 ]]; then
        print "What? More than 3 $LETTER's! That's an error."
        exit

      else
        if [[ "$VERBOSITY" -ge 1 ]]; then
          print "Letter $LETTER appears in ${GUESS[i]} $COUNT times"
        fi

        # Set up a template for regex using string replacement to substitute
        # ^$LETTER for each "." in ANSWER
        TEMPLATE=${ANSWER//./"[^$LETTER]"}      
        if [[ "$VERBOSITY" -eq 2 ]]; then
          print "TEMPLATE is $TEMPLATE"
          print
        fi
  
        # Now select only those words which match pattern
        if [[ "$VERBOSITY" -eq 2 ]]; then
          print "Selecting remaining words matching $TEMPLATE"
        fi
        grep --regexp="$TEMPLATE" list.tmp > list_$i.txt

        # Tabulate and display results after matching for TEMPLATE
        PREV=$(wc -l < list.tmp)
        PREV=${PREV// }
        CNT=$(wc -l < list_$i.txt)
        CNT=${CNT// }
        DISCARD=$(( $PREV-$CNT ))
        print "After excluding words with $LETTER, $DISCARD further words eliminated; $CNT words remaining."
        if [[ "$VERBOSITY" -ge 1 ]]; then
          print -n "See list of remaining words? (y/n)"
          read -r RESP3
          if [[ "$RESP3" = "y" ]]; then
            cat list_$i.txt 
          fi
        fi
              
        # Update list.tmp
        cat list_$i.txt > list.tmp

      fi

    done

  elif [[ "$LEN" -eq 0 ]]; then
    print -n "There are no letters which do not match. Correct? (y/n)"
    read -r RESP1
      if [[ "$RESP1" = "y" ]]; then
        print "All letters matched in some way. You are nearly there."      
      elif [[ "$RESP1" = "n" ]]; then
        print -n "Error in determining \$WRONG"
        exit
      else
        print "Invalid entry."
        exit
      fi

  else
  # Some kind of error in LEN
    print "Error in \$LEN"
    exit

  fi

  # Tabulate and display results after step 3
  CNT=$(wc -l < list_$i.txt)
  CNT=${CNT// }
  DISCARD=$(( $PART3-$CNT ))
  print
  print "After step 3, $DISCARD further words eliminated; $CNT words remaining."
  if [[ "$VERBOSITY" -ge 1 ]]; then
    print -n "See list of remaining words? (y/n)"
    read -r RESP3
    if [[ "$RESP3" = "y" ]]; then
      cat list_$i.txt
    fi
  fi
  
  # Update list.tmp
  cat list_$i.txt > list.tmp
  
  if [[ "$VERBOSITY" -eq 2 ]]; then          
    print "Returning execution to wordle_solver.master.v0.2"
  fi

  return    
